P8105 Homework 1
================
Maria Serafini

## Problem 1

**This chunk loads the `early_january_weather` dataset from the
moderndive package and finds the mean, median, and standard deviation of
the temperature and humidity recordings and stores the values for
in-line use**

``` r
# loads dataset early_january_weather
data("early_january_weather")

# calculates and saves value for the mean, median, and standard deviation of temperature variable
mean_temp <- mean(pull(early_january_weather, temp))
median_temp <- median(pull(early_january_weather, temp))
std_temp <- sd(pull(early_january_weather, temp))

# calculates and saves value the mean, median, and standard deviation of humidity variable
mean_humid <- mean(pull(early_january_weather, humid))
median_humid <- median(pull(early_january_weather, humid))
std_humid <- sd(pull(early_january_weather, humid))
```

**The dataset `early_january_weather` includes meterological data for
LGA, JFK, and EWR for the month of January 2013 and contains 358
observations (rows) representing hourly measurements and 15 variables
(columns):**

- `origin` - weather station (LGA, JFK, EWR)
- `year` - year at time of recording (2013)
- `month` - month at time of recording (1)
- `day` - day of the month at time of recording (1, 15)
- `hour` - hour of the day at time of recording (0, 23)
- `temp` - temperature (degrees F, *mean*: 39.58, *median*: 39.02,
  *std*: 7.06)
- `dewp` - dewpoint (degrees F)
- `humid` - relative humidity (*mean*: 65.48, *median*: 61.67, *std*:
  18.95)
- `wind_dir` - wind direction (degrees)
- `wind_speed` - wind speed (mph)
- `wind_gust` - wind gust speed (mph)
- `precip` - precipitation (inches)
- `pressure` - sea level pressure (milibars)
- `visib` - visibility (miles)
- `time_hour` - date and hour of recording as a POSIXct date

# 

**This chunk makes a scatterplot of recorded temperature by date/hour of
the recording with color coding to indicate relative humidity and saves
the plot as a pdf**

``` r
# creates scatterplot of temperature by date/hour of recording and color coded based on relative humidity
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point()
```

![](p8105_hw1_mas2514_files/figure-gfm/scatterplot-1.png)<!-- -->

``` r
# saves scatterplot as pdf
ggsave("jan_weather_plot.pdf", height = 5, width = 7)
```

The scatterplot `jan_weather_plot` above shows the hourly temperature
recordings from January 1st to 15th, with point color representing the
relative humidity at the time of the recording. The temperature
recordings display a daily pattern of rising during the day and falling
at night, with most of the recordings staying within a range of 30 to 50
degrees Fahrenheit. Across the two week recording period, temperatures
appear relatively stable but with a dip at the start of January and a
peak by mid-January, suggesting a slight warming trend. Relative
humidity is more variable, with lower humidity clustering in the early
part of the month and higher humidity values becoming more common toward
the middle of the month. Notably, there is a cluster of recordings
around January 12-13th with lower temperature variability throughout the
day and high relative humidity.

## Problem 2

**This chunk creates the data frame `sample_df` containing a sample of
size 10 from a random normal variable, a logical vector to indicate
whether sample elements are greater than 0, a character vector of length
10, and a factor vector of length 10 with 3 different factor levels
(good, better, best). It also takes the mean of each variable in the
dataframe and saves the values for inline printing**

``` r
# creates dataframe of sample 10 with logical, character, and factor vectors 
sample_df <- 
  tibble(
    norm_samp = rnorm(10),
    norm_samp_pos = norm_samp > 0, 
    vec_char = c("cookie dough", "mint chip", "strawberry", "vanilla", "chocolate", 
                 "rocky road", "butter pecan", "cookies n cream", "chocolate chip", "caramel"),
    vec_factor = factor(c("best", "better", "good", "better", "best", "good", "good", "best", 
                          "better", "better"))
  )

# gives mean of each variable in sample_df
mean_samp <- mean(pull(sample_df, norm_samp))
mean_samp_pos <- mean(pull(sample_df, norm_samp_pos))
mean_char <- mean(pull(sample_df, vec_char))
```

    ## Warning in mean.default(pull(sample_df, vec_char)): argument is not numeric or
    ## logical: returning NA

``` r
mean_factor <- mean(pull(sample_df, vec_factor))
```

    ## Warning in mean.default(pull(sample_df, vec_factor)): argument is not numeric
    ## or logical: returning NA

Using the `mean()` function to take the mean of each of the variables in
`sample_df` returns -0.39 for the mean of the sample and 0.3 for the
mean of the logical vector, `norm_samp_pos`. For the character and
factor vectors, applying `mean()` gives a warning message ‘argument is
not numeric or logical’ and returns ‘NA’ for the character vector,
`vec_char`, and ‘NA’ for the factor vector, `vec_factor`.

**The chunk below applies the `as.numeric` function to the logical,
character, and vector variables from `sample_df`**

``` r
# applies as.numeric function to sample_df variables to corece to numeric values
as.numeric(pull(sample_df, norm_samp_pos))
as.numeric(pull(sample_df, vec_char))
as.numeric(pull(sample_df, vec_factor))
```

Applying the `as.numeric()` function to `norm_samp_pos`, returns ‘0, 0,
1, 0, 1, 0, 0, 0, 0, 1’ because TRUE has a value of ‘1’ and FALSE has a
value of ‘0’ for logical vectors. Applying the `mean()` function
therefore returns a value that represents the proportion of TRUE values.
For the factor vector, `vec_factor`, `as.numeric()` returns ‘1, 2, 3, 2,
1, 3, 3, 1, 2, 2’ because each factor level is arbitrarily assigned a
value (best = ‘1’, better = ‘2’, good = ‘3’, in this case). ‘NA’ is
returned when applying the `mean()` function to factor vectors because
the assigned values do not actually represent the order of the levels
and taking the mean would therefore be meaningless. Applying
`as.numeric()` to `vec_char` gives a warning message, ‘NAs introduced by
coercion’, and returns ‘NA, NA, NA, NA, NA, NA, NA, NA, NA, NA’ because
non-numerical characters cannot be coerced into integers, thus applying
the `mean()` function also returns ‘NA’ because a mean requires
numerical data to be calculated.
