---
title: "P8105 Homework 1"
author: "Maria Serafini"
output: github_document
---

## Problem 1

```{r setup, include=FALSE}
library(moderndive)
library(tidyverse)
```


__This chunk loads the `early_january_weather` dataset from the moderndive package and finds the mean, median, and standard deviation of the temperature and humidity recordings and stores the values for in-line use__ 

```{r early_january_weather data}
# loads dataset early_january_weather
data("early_january_weather")

# calculates and saves value for the mean, median, and standard deviation of temperature variable
mean_temp <- mean(pull(early_january_weather, temp))
median_temp <- median(pull(early_january_weather, temp))
std_temp <- sd(pull(early_january_weather, temp))

# calculates and saves value for the mean, median, and standard deviation of humidity variable
mean_humid <- mean(pull(early_january_weather, humid))
median_humid <- median(pull(early_january_weather, humid))
std_humid <- sd(pull(early_january_weather, humid))
```

__The dataset `early_january_weather` includes meterological data for LGA, JFK, and EWR for the month of January 2013 and contains `r nrow(early_january_weather)` observations (rows) representing hourly measurements and `r ncol(early_january_weather)` variables (columns):__ 

* `origin` - weather station (LGA, JFK, EWR)
* `year` - year at time of recording (2013)
* `month` - month at time of recording (1)
* `day` - day of the month at time of recording (`r range(pull(early_january_weather, day))`)
* `hour` - hour of the day at time of recording (`r range(pull(early_january_weather, hour))`)
* `temp` - temperature (degrees F, _mean_: `r round(mean_temp, digits = 2)`, _median_: `r round(median_temp, digits = 2)`, _std_: `r round(std_temp, digits = 2)`)
* `dewp` - dewpoint (degrees F)
* `humid` - relative humidity (_mean_: `r round(mean_humid, digits = 2)`, _median_: `r round(median_humid, digits = 2)`, _std_: `r round(std_humid, digits = 2)`)
* `wind_dir` - wind direction (degrees)
* `wind_speed` - wind speed (mph) 
* `wind_gust` - wind gust speed (mph)
* `precip` - precipitation (inches)
* `pressure` - sea level pressure (milibars)
* `visib` - visibility (miles)
* `time_hour` - date and hour of recording as a POSIXct date

#
__This chunk makes a scatterplot of recorded temperature by date/hour of the recording with color coding to indicate relative humidity and saves the plot as a png__

```{r scatterplot}
# creates scatterplot of temperature by date/hour of recording and adds color coding based on relative humidity
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point()

# saves scatterplot as png
ggsave("jan_weather_plot.png", height = 5, width = 7)
```

The scatterplot `jan_weather_plot` above shows the hourly temperature recordings from January 1st to 15th, with point color representing the relative humidity at the time of the recording. The temperature recordings display a daily pattern of rising during the day and falling at night, with most of the recordings staying within a range of 30 to 50 degrees Fahrenheit. Across the two week recording period, temperatures appear relatively stable but with a dip at the start of January and a peak by mid-January, suggesting a slight warming trend. Relative humidity is more variable, with lower humidity clustering in the early part of the month and higher humidity values becoming more common toward the middle of the month. Notably, there is a cluster of recordings around January 12-13th with lower temperature variability throughout the day and high relative humidity.


## Problem 2

__This chunk creates the data frame `sample_df` containing a sample of size 10 from a random normal variable, a logical vector to indicate whether sample elements are greater than 0, a character vector of length 10, and a factor vector of length 10 with 3 different factor levels (good, better, best). It also takes the mean of each variable in the dataframe and saves the values for inline printing__ 

```{r random sample}
# creates dataframe of sample 10 with logical, character, and factor vectors 
sample_df <- 
  tibble(
    norm_samp = rnorm(10),
    norm_samp_pos = norm_samp > 0, 
    vec_char = c("cookie dough", "mint chip", "strawberry", "vanilla", "chocolate", 
                 "rocky road", "butter pecan", "cookies n cream", "chocolate chip", "caramel"),
    vec_factor = factor(c("best", "better", "good", "better", "best", "good", "good", "best", 
                          "better", "better"))
  )

# gives mean of each variable in sample_df
mean_samp <- mean(pull(sample_df, norm_samp))
mean_samp_pos <- mean(pull(sample_df, norm_samp_pos))
mean_char <- mean(pull(sample_df, vec_char))
mean_factor <- mean(pull(sample_df, vec_factor))
```

Using the `mean()` function to take the mean of each of the variables in `sample_df` returns `r round(mean_samp, digits = 2)` for the mean of the sample and `r round(mean_samp_pos, digits = 2)` for the mean of the logical vector, `norm_samp_pos`. For the character and factor vectors, applying `mean()` gives a warning message 'argument is not numeric or logical' and returns '`r mean_char`' for the character vector, `vec_char`, and '`r mean_factor`' for the factor vector, `vec_factor`.


__The chunk below applies the `as.numeric` function to the logical, character, and vector variables from `sample_df`__ 
```{r, eval=FALSE}
# applies as.numeric function to sample_df variables to corece to numeric values
as.numeric(pull(sample_df, norm_samp_pos))
as.numeric(pull(sample_df, vec_char))
as.numeric(pull(sample_df, vec_factor))
```

Applying the `as.numeric()` function to `norm_samp_pos`, returns '`r as.numeric(pull(sample_df, norm_samp_pos))`' because TRUE has a value of '1' and FALSE has a value of '0' for logical variables. Applying the `mean()` function therefore returns a value that represents the proportion of TRUE values. For the factor vector, `vec_factor`, `as.numeric()` returns '`r as.numeric(pull(sample_df, vec_factor))`' because each factor level is arbitrarily assigned a value (best = '1', better = '2', good = '3', in this case). 'NA' is returned when applying the `mean()` function to factor variables because the assigned values do not actually represent the order of the levels and taking the mean would therefore be meaningless. Applying `as.numeric()` to `vec_char` gives a warning message, 'NAs introduced by coercion', and returns '`r as.numeric(pull(sample_df, vec_char))`' because non-numerical character data cannot be coerced to numeric data, thus applying the `mean()` function also returns 'NA' because a mean requires numerical data to be calculated. 
